---
title: "Practical 7"
author: "Hsuan Lee"
output: html_document
---
```{r}
library(MASS)
library(splines)
library(ISLR)
library(tidyverse)
options(scipen = 999)
```

```{r}
set.seed(45)
```

## Prediction plot

**1. Create a function called pred_plot() that takes as input an lm object, which outputs the above plot but with a prediction line generated from the model object using the predict() method.**
```{r}
pred_plot <- 
  function(model, data, 
           IV, DV,
           # IV is the IV's number of column
           IV.col, length.out){
    # create the data from min x to max x with certain distance
    x <- data.frame(lstat = seq(min(data[,IV.col]), max(data[,IV.col]), length.out = length.out))
    # create the data frame for the predicted value
    pred <- data.frame(medv = predict(model, newdata = x), x = x[,1])
    # plot
    data %>%
      ggplot(aes(x = IV, y = DV)) +
      geom_point() +
      geom_line(aes(x = x, y = medv), data = pred, col = "blue") +
      theme_minimal()
  }
```

**2. Create a linear regression object called lin_mod which models medv as a function of lstat. Check if your prediction plot works by running pred_plot(lin_mod). Do you see anything out of the ordinary with the predictions?**
```{r}
lin_mod <- lm(medv ~ lstat, data = Boston)
Boston <- Boston
pred_plot(model = lin_mod, data = Boston, IV = Boston$lstat, DV = Boston$medv, IV.col = 13, length.out = 10000)
```

## Polynomial regression

**3. Create another linear model pn3_mod, where you add the second and third-degree polynomial terms I(lstat^2) and I(lstat^3) to the formula. Create a pred_plot() with this model.**
```{r}
pn3_mod <- lm(medv ~ lstat + I(lstat^2) + I(lstat^3), data = Boston)
pred_plot(model = pn3_mod, data = Boston, IV = Boston$lstat, DV = Boston$medv, IV.col = 13, length.out = 1000)
```

**4. Play around with the poly() function. What output does it generate with the arguments degree = 3 and raw = TRUE?**
```{r}
poly(1:3, degree = 3, raw = T)
```

It generates the quaratic and cubed term from the given data.

**5. Use the poly() function directly in the model formula to create a 3rd-degree polynomial regression predicting medv using lstat. Compare the prediction plot to the previous prediction plot you made. What happens if you change the poly() function to raw = FALSE?**
```{r}
pn3_mod2 <- lm(medv~ poly(lstat, degree = 3, raw = T), data = Boston)
summary(pn3_mod2)
pred_plot(model = pn3_mod2, data = Boston, IV = Boston$lstat, DV = Boston$medv, IV.col = 13, length.out = 1000)
```

The plot is same as the previous one. With raw = FALSE, poly() computes an orthogonal polynomial.  This does not change the fitted values but you can see whether a certain order in the polynomial significantly improves the regression over the lower orders. You can check the summary(pn3_mod2).

Orthogonal polynomial eliminates the multicolinearity

## Piecewise regression

**6. Create a model called pw2_mod with one predictor: I(lstat <= median(lstat)). Create a pred_plot with this model. Use the coefficients in coef(pw2_mod) to find out what the predicted value for a low-lstat neighbourhood is.**
```{r}
# If we wanna change something for x in regression than we can use I() to do that
pw2_mod <- lm(medv~ I(lstat <= median(lstat)), data = Boston)
pred_plot(model = pw2_mod, data = Boston, IV = Boston$lstat, DV = Boston$medv, IV.col = 13, length.out = 1000)

coef(pw2_mod)
# so here its just a t-test
# so the predicted value of lstat below the medain lstat will be:
16.67747 + 11.71067*1 # 28.38814

# the predicted value of lstat below the medain lstat will be:
16.67747 + 11.71067*0
```

**7. Use the cut() function in the formula to generate a piecewise regression model called pw5_mod that contains 5 equally spaced sections. Again, plot the result using pred_plot.**
```{r}
pw5_mod <- lm(medv ~ cut(lstat, 5), data = Boston)

pred_plot(model = pw5_mod, data = Boston, IV = Boston$lstat, DV = Boston$medv, IV.col = 13, length.out = 1000)
```

Note that the sections generated by cut() are equally spaced in terms of lstat, but they do not have equal amounts of data. In fact, the last section has only 9 data points to work with:
```{r}
table(cut(Boston$lstat, 5))
```

**8. Optional: Create a piecewise regression model pwq_mod where the sections are not equally spaced, but have equal amounts of training data. Hint: use the quantile() function.**
```{r}
segment <- c(-Inf, quantile(Boston$lstat, probs = c(0.2, 0.4, 0.6, 0.8)), Inf)

pwq_mod <- lm(medv ~ cut(lstat, segment), data = Boston)

pred_plot(model = pwq_mod, data = Boston, IV = Boston$lstat, DV = Boston$medv, IV.col = 13, length.out = 1000)
```

```{r}
table(cut(Boston$lstat, segment))
```

## Piecewise polynomial regression

**9. This function does not have comments. Copy - paste the function and add comments to each line. To figure out what each line does, you can first create “fake” vec and knots variables, for example vec <- 1:20 and knots <- 2 and try out the lines separately.**
```{r}
piecewise_cubic_basis <- function(vec, knots = 1) {
  # if there's one segment, a cubic polynomial is employed
  if (knots == 0) return(poly(vec, degree = 3, raw = TRUE))
  
  # split the given data into the given segments
  cut_vec <- cut(vec, breaks = knots + 1)
  
  # create a blank matrix for storing the results from for-loop
  out <- matrix(nrow = length(vec), ncol = 0)
  
  # a loop for computing cubic polynomial for each segment
  for (lvl in levels(cut_vec)) {
    # put in all the given IV
    tmp <- vec
    # extract the present segment, as it only compute for this segment
    tmp[cut_vec != lvl] <- 0
    # copute the polynomial of the segment and store it into the matrix
    out <- cbind(out, poly(tmp, degree = 3, raw = TRUE))
  }
  
  # return the values of piecewise polynomial matrix
  out
}
```

**10. Create piecewise cubic models with 1, 2, and 3 knots (pc1_mod - pc3_mod) using this piecewise cubic basis function. Compare them using the pred_plot() function.**
```{r}
pc1_mod <- lm(medv~ piecewise_cubic_basis(lstat, 1), data = Boston)
pc2_mod <- lm(medv ~ piecewise_cubic_basis(lstat, 2), data = Boston)
pc3_mod <- lm(medv ~ piecewise_cubic_basis(lstat, 3), data = Boston)
```

*Plot them out*
```{r}
pred_plot(model = pc1_mod, data = Boston, IV = Boston$lstat, DV = Boston$medv, IV.col = 13, length.out = 1000)

pred_plot(model = pc2_mod, data = Boston, IV = Boston$lstat, DV = Boston$medv, IV.col = 13, length.out = 1000)

pred_plot(model = pc3_mod, data = Boston, IV = Boston$lstat, DV = Boston$medv, IV.col = 13, length.out = 1000)
```

## Spline

**11. Create a data frame called boston_tpb with the columns medv and lstat from the Boston dataset.**
```{r}
boston_tpb <- data.frame(medv = Boston$medv, lstat = Boston$lstat)
```

**12. Now use mutate to add squared and cubed versions of the lstat variable to this dataset.**
```{r}
boston_tpb <- 
  boston_tpb %>%
  mutate(lstat2 = lstat^2,
         lstat3 = lstat^3)
```

**13. Use mutate to add a column lstat_tpb to this dataset which is 0 below the median and has value (lstat - median(lstat))^3 above the median. Tip: you may want to use ifelse() within your mutate() call.**
```{r}
boston_tpb <- 
  boston_tpb %>%
  mutate(lstat_tpb = ifelse(lstat < median(lstat), 0, (lstat - median(lstat))^3))
```

**14. Create a linear model tpb_mod using the lm() function. How many predictors are in the model? How many degrees of freedom does this model have?**
```{r}
tpb_mod <- lm(medv~ ., data = boston_tpb)
summary(tpb_mod)
```

5 predictors so 5 degrees of freedom.

**15. Create a cubic spline model bs1_mod with a knot at the median using the bs() function. Compare its predictions to those of the tpb_mod using the predict() function on both models.**
```{r}
bs1_mod <- lm(medv ~ bs(lstat, knots = median(lstat)), data = Boston)
summary(bs1_mod)
```

```{r}
# Comparing the predictions from the two models: negligible absolute difference
mean(abs(predict(bs1_mod) - predict(tpb_mod)))
```

**16. Create a prediction plot from the bs1_mod object using the plot_pred() function.**
```{r}
pred_plot(model = bs1_mod, data = Boston, IV = Boston$lstat, DV = Boston$medv, IV.col = 13, length.out = 1000)
```

Note that this line fits very well, but at the right end of the plot, the curve slopes up. Theoretically, this is unexpected – always pay attention to which predictions you are making and whether that behaviour is in line with your expectations.

The last extension we will look at is the natural spline. This works in the same way as the cubic spline, with the additional constraint that the function is required to be linear at the boundaries. The ns() function from the splines package is for generating the basis representation for a natural spline.

**17. Create a natural cubic spline model (ns3_mod) with 3 degrees of freedom using the ns() function. Plot it, and compare it to the bs1_mod.**
```{r}
# with 3 degree of freedom
ns3_mod <- lm(medv ~ ns(lstat, df = 3), data = Boston)

pred_plot(model = ns3_mod, data = Boston, IV = Boston$lstat, DV = Boston$medv, IV.col = 13, length.out = 1000)
```

Good fit with linear ends.

**18. Plot lin_mod, pn3_mod, pw5_mod, pc3_mod, bs1_mod, and ns3_mod and give them nice titles by adding + ggtitle("My title") to the plot. You may use the function plot_grid() from the package cowplot to put your plots in a grid.**
```{r}
library(cowplot)
```

```{r}
plot_grid(
pred_plot(model = lin_mod, data = Boston, IV = Boston$lstat, DV = Boston$medv, IV.col = 13, length.out = 1000) + ggtitle("Linear regression"),
pred_plot(model = pn3_mod, data = Boston, IV = Boston$lstat, DV = Boston$medv, IV.col = 13, length.out = 1000) + ggtitle("Polynomial"),
pred_plot(model = pw5_mod, data = Boston, IV = Boston$lstat, DV = Boston$medv, IV.col = 13, length.out = 1000) + ggtitle("Piecewise constant"),
pred_plot(model = pc3_mod, data = Boston, IV = Boston$lstat, DV = Boston$medv, IV.col = 13, length.out = 1000) + ggtitle("Piecewise cubic"),
pred_plot(model = bs1_mod, data = Boston, IV = Boston$lstat, DV = Boston$medv, IV.col = 13, length.out = 1000) + ggtitle("Cubic spline"),
pred_plot(model = ns3_mod, data = Boston, IV = Boston$lstat, DV = Boston$medv, IV.col = 13, length.out = 1000) + ggtitle("Natural spline")
)
```
