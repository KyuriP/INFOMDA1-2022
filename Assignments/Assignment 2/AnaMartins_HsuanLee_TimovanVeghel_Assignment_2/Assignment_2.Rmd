---
title: "Can we predict IMDb movie ratings?"
author: "Ana Martins, Hsuan Lee, Timo van Veghel"
date: "October/November 2022"
output: html_document
---

## Goals 

In this project, we aim to find out if there is a way to predict IMDb movie ratings based on a dataset we retrieve from the [IMDb API](https://imdb-api.com). We aim to find which variables are relevant to the rating so we can create a prediction model which, hopefully, will let us know before anyone else which movies we should be going to the cinema for. 
However, there is no garantee that we can actually predict the score based on such superficial values, as most of the stuff that actually makes up a movie is in the movie itself, and not in metrics like the runtime. So we will also try to predict the gross of a movie, based on the parameters available, as that seems on a first thought more predictable based on the genre (e.g. more people watch romcoms than history documentaries) and on the popularity of the actors (e.g. a movie is much more likely to make more money if you spend the money to go and hire Jennifer Aniston).

## About the Dataset

The dataset we will be using is taken from the [IMDb API](https://imdb-api.com) on the 4th of November of 2022, as we did not find any dataset online that satisfied what we wanted (they were either too big, too small, or had wrong data). The maximum amount of data we can get at once is 250 movies, so what we do to try to generate (mostly) random data is searching for movies with each of the genres available and getting them by ascending and descending alphabetical order (see [data/movie_data_generating.py](data/movie_data_generating.py) for more details). The starting dataset contains 11649 random (see below why we can call them random) movies that are on IMDB.

The dataset has 14 variables: `id`, `image`, `title`, `description`, `runtimeStr`, `genres`, `genresList`, `contentRating`, `imDbRating`, `imDbRatingVotes`, `metacriticRating`, `plot`, `stars` and `starList`.

We will be taking away variables that do not interest us, like `image`, `genresList` (we have the genres in `genres` already), `plot` and `starList` (again, we have the starts in `stars` already), as those are not useful to analyse or to look back on. Variables like the `stars` are also not useful to analyse, as if we tried to fit a model to so many actors we would definitely be overfitting, but they are good to keep if we want to look back at them later or to use them for constructing dummy variables. And the variables we will try to predict are `imDbRating`. Another particularity of the dataset is that this data was already taken only for Feature Films, for runtime longer than 60 minutes and for more IMDb votes than 25000 (what IMDb considers to make the rating official) to eliminate titles we do not want to analyse.

## Getting the Data

We start by getting our initial dataset:

```{r}
library(tidyverse)
```

```{r}
movies <- read_csv("data/movie_data.csv")
```

Let us clean this up a bit so we do not have to carry around more than we need to:

```{r}
movies <-
  movies %>%
  select(-image,-genreList,-plot,-starList)
```

```{r}
movies <-
  movies %>%
  mutate(runtime = as.numeric(gsub(' min', '', runtimeStr))) %>%
  select(-runtimeStr)
```

```{r}
movies <-
  movies %>% 
  mutate(contentRating = as.factor(contentRating))
```

```{r}
movies <-
  movies %>% 
  mutate(year = as.numeric(gsub('[()]', '', description))) %>% 
  select(-description)
```


Actually, looking at the `stars`, we can see that the first name listed is the Director of that film, so let us take them out.

```{r}
movies <-
  movies %>% 
  mutate(director = sub(", .*", "", movies$stars)) %>% 
  mutate(stars = substring(stars, first = nchar(director) + 3)) %>% 
  mutate(actors = stars)
```


Also, because of the way the data was retrieved, we have multiples in there (e.g. on movie can be on the action and drama genres and get retrieved both times), so let's get rid of them.

```{r}
movies <-
  movies %>% 
  filter(!duplicated(id))
```

## Creating New Useful Variables

Seeing as our dataset right now is mostly made up of character variables, this will not be very useful. So, we will start by transforming the `genres` into dummy variables for each one of them.

```{r}
movies <-
  movies %>% 
  mutate(action = ifelse(grepl("Action", genres, fixed = TRUE), 1, 0),
         adventure = ifelse(grepl("Adventure", genres, fixed = TRUE), 1, 0),
         animation = ifelse(grepl("Animation", genres, fixed = TRUE), 1, 0),
         biography = ifelse(grepl("Biography", genres, fixed = TRUE), 1, 0),
         comedy = ifelse(grepl("Comedy", genres, fixed = TRUE), 1, 0),
         crime = ifelse(grepl("Crime", genres, fixed = TRUE), 1, 0),
         documentary = ifelse(grepl("Documentary", genres, fixed = TRUE), 1, 0),
         drama = ifelse(grepl("Drama", genres, fixed = TRUE), 1, 0),
         family = ifelse(grepl("Family", genres, fixed = TRUE), 1, 0),
         fantasy = ifelse(grepl("Fantasy", genres, fixed = TRUE), 1, 0),
         filmnoir = ifelse(grepl("Film-Noir", genres, fixed = TRUE), 1, 0),
         gameshow = ifelse(grepl("Game-Show", genres, fixed = TRUE), 1, 0),
         history = ifelse(grepl("History", genres, fixed = TRUE), 1, 0),
         horror = ifelse(grepl("Horror", genres, fixed = TRUE), 1, 0),
         music = ifelse(grepl("Music", genres, fixed = TRUE), 1, 0),
         musical = ifelse(grepl("Musical", genres, fixed = TRUE), 1, 0),
         mystery = ifelse(grepl("Mystery", genres, fixed = TRUE), 1, 0),
         news = ifelse(grepl("News", genres, fixed = TRUE), 1, 0),
         realitytv = ifelse(grepl("Reality-TV", genres, fixed = TRUE), 1, 0),
         romance = ifelse(grepl("Romance", genres, fixed = TRUE), 1, 0),
         scifi = ifelse(grepl("Sci-Fi", genres, fixed = TRUE), 1, 0),
         sport = ifelse(grepl("Sport", genres, fixed = TRUE), 1, 0),
         talkshow = ifelse(grepl("Talk-Show", genres, fixed = TRUE), 1, 0),
         thriller = ifelse(grepl("Thriller", genres, fixed = TRUE), 1, 0),
         war = ifelse(grepl("War", genres, fixed = TRUE), 1, 0),
         western = ifelse(grepl("Western", genres, fixed = TRUE), 1, 0),) %>% 
  select(-genres)
```

These are all of the Genres available in the IMDb API. However, when retrieving the values, the search couldn't find any movies with certain genres within our search criteria (runtime > 60 and num of votes > 25000), so we can take those out to not carry variables we don't need.

```{r}
movies = movies[ , colSums(movies != 0, na.rm = TRUE) > 0]
```

Now, to use the `director` variable in some way, we need to create another dummy value. For this, we are going to create `director_top250`. Let us load our second dataset:

```{r}
top250 <- read_csv("data/top250_data.csv")
```

Again, let us arrange it in a similar way as the last one:

```{r}
top250 <-
  top250 %>%
  select(-fullTitle, -image)
```

From here, we only need the Directors' names:

```{r}
top250 <-
  top250 %>% 
  mutate(director = sub(", .*", "", top250$crew))
top250 <-
  top250 %>% 
  mutate(director = sub("dir.", "", top250$director))
top250 <-
  top250 %>% 
  mutate(director = gsub("[()]", "", top250$director))
top250 <-
  top250 %>% 
  mutate(director = str_sub(director, end = -2))
```

```{r}
directors <- top250$director 
directors <- unique(directors)
```

```{r}
movies <-
  movies %>% 
  mutate(top_director = ifelse(director %in% directors, 1, 0))
```

It would be useful to have a similar thing for the actors:

```{r}
top250 <-
  top250 %>% 
  mutate(director = sub(", .*", "", top250$crew)) %>% 
  mutate(crew = substring(crew, first = nchar(director) + 3))
```

```{r}
actors <- unlist(strsplit(top250$crew, ", "))
```

```{r}
movies <-
  movies %>% 
  mutate(actors = stars)
movies <-
  movies %>%
  mutate(actor1 = sub(", .*", "", movies$stars)) %>%
  mutate(stars = substring(stars, first = nchar(actor1) + 3))
movies <-
  movies %>%
  mutate(actor2 = sub(", .*", "", movies$stars)) %>%
  mutate(stars = substring(stars, first = nchar(actor2) + 3))
movies <- movies %>%
  mutate(actor3 = sub(", .*", "", movies$stars)) %>%
  mutate(stars = substring(stars, first = nchar(actor3) + 3))
movies <- movies %>%
  mutate(actor4 = sub(", .*", "", movies$stars)) %>%
  mutate(stars = substring(stars, first = nchar(actor4) + 3))
movies <- movies %>%
  mutate(actor5 = sub(", .*", "", movies$stars)) %>%
  mutate(stars = substring(stars, first = nchar(actor5) + 3))
movies <- movies %>%
  mutate(actor6 = sub(", .*", "", movies$stars)) %>%
  mutate(stars = substring(stars, first = nchar(actor6) + 3))
movies <- movies %>%
  mutate(actor7 = sub(", .*", "", movies$stars)) %>%
  mutate(stars = substring(stars, first = nchar(actor7) + 3))
movies <- movies %>%
  mutate(actor8 = sub(", .*", "", movies$stars)) %>%
  mutate(stars = substring(stars, first = nchar(actor8) + 3))
movies <- movies %>%
  mutate(actor9 = sub(", .*", "", movies$stars)) %>%
  mutate(stars = substring(stars, first = nchar(actor9) + 3))
movies <- movies %>%
  mutate(actor10 = sub(", .*", "", movies$stars)) %>%
  mutate(stars = substring(stars, first = nchar(actor10) + 3))
movies <- movies %>%
  mutate(actor11 = sub(", .*", "", movies$stars)) %>%
  mutate(stars = substring(stars, first = nchar(actor11) + 3))
movies <- movies %>%
  mutate(actor12 = sub(", .*", "", movies$stars)) %>%
  mutate(stars = substring(stars, first = nchar(actor12) + 3))
movies <- movies %>%
  mutate(actor13 = sub(", .*", "", movies$stars)) %>%
  mutate(stars = substring(stars, first = nchar(actor13) + 3))
movies <- movies %>%
  mutate(actor14 = sub(", .*", "", movies$stars)) %>%
  mutate(stars = substring(stars, first = nchar(actor14) + 3))
movies <-
  movies %>% 
  mutate(actor15 = stars) %>% 
  select(-stars)
```

```{r}
movies <-
  movies %>% 
  mutate(top_actor = ifelse(actor1 %in% actors | actor2 %in% actors | actor3 %in% actors | actor4 %in% actors | actor5 %in% actors | actor6 %in% actors | actor7 %in% actors | actor8 %in% actors | actor9 %in% actors | actor10 %in% actors | actor11 %in% actors | actor12 %in% actors | actor13 %in% actors | actor14 %in% actors | actor15 %in% actors, 1, 0))
```

```{r}
movies <-
  movies %>% 
  select(-actor1, -actor2, -actor3, -actor4, -actor5, -actor6, -actor7, -actor8, -actor9, -actor10, -actor11, -actor12, -actor13, -actor14, -actor15)
```


## Exploratory Data Analysis

Let us now start by seeing what we are working with, by seeing some of the variables compared to each other, so we can start understanding what variables correlate to the IMDb Rating.

```{r}
summary(movies)
```

We can take a quick look to what these statistics tell us, just for fun (and also to make sure our sample is actually random).
The minimum rating film we have from IMDb users has 1.0 out of 10 and the maximum has 9.2, with the mean of the score being 6.74. The minimum rating film we have from critics has 6.0 out of 100 and the maximum has the max score of 100, with a mean at 59.61, which is close-ich to the IMDb ratings. It is expected that the critics scores are lower than the IMDb ratings in general though, so this seems about right.
The lowest runtime we have has 46 minutes, which means somehow a movie got to escape the API filter, and the longest is longer than 5 hours (I had to look that up... it's an italian movie, of course).
The first movie we have is from 1920 and the latest is from 2022 (which makes sense as this was taken directly from the IMDb database, which is always up to date with the movies coming out). The mean for the year is at 2001, which means we have more recent movies than older movies, which makes sense since there are more movies being produced now.
Looking at the genres, we can see the genre that we have more of is drama, with about half of the movies earning that title, and the one we have least of is Reality-TV, only having one movie from that category.
We have almost 20% of movies having a top director, while only 0.4% have a top actor.

```{r}
movies %>% 
  ggplot(aes(x = imDbRating)) +
  geom_histogram(binwidth = 0.5) +
  theme_minimal() +
  xlim(0, 10)
```

Referring back to the "random" movies remark, here we can clearly see that the IMDb scores follow a gaussian trend, which let's us treat the data as a random sample.
